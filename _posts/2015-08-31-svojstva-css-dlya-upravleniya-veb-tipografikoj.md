---
layout: post
title: "Свойства CSS для управления веб-типографикой"
categories: [development]
date: 2015-08-31 18:00:00
tags: [css, translation, sitepoint]
description: "Управление веб-типографикой с text-transform, white-space, overflow-wrap, hyphens, word-spacing, text-indent и т.д."
original: "http://www.sitepoint.com/css-properties-to-control-web-typography/"
original_author: "Maria Antonietta Perna"
original_name: "CSS Properties to Control Web Typography"
prism: yes
---
Преимуществом веб-типографики является то, что она базируется на знаниях, накопленных за столетия развития традиционной печатной типографики. По той же причине веб-типографика должна следовать стандартам лучших практик и передового опыта.

Однако, веб это пространство коммуникации со своими особенностями. Настолько, что плавный переход от печати к веб-типографике становится вызовом. Джейсон Санта Мария в своей книге [о веб-типографике](https://www.sitepoint.com/premium/books/on-web-typography) пишет:

>Печатные книги это статический формат. От первого дизайнерского макета книга без изменений проходит свой путь к вам через типографию, склад и книжную полку. В точно таком же виде, как было задумано.

В вебе один и тот же сайт может выглядеть различно в зависимости от многих факторов --- различий устройств, разрешения их экранов, личных настроек браузеров и прочего. Как далее пишет Джейсон, некоторые из этих факторов...

>Могут дать впечатление, что шрифт слишком мелкий, другие выносят часть содержимого за пределы экрана, а третьи могут полностью испортить просмотр страницы.

Но также известно, что "веб это лучшее место для текста". Текст в Интернете можно "искать, копировать, переводить, передавать в виде ссылки, распечатывать; текст в вебе удобен и доступен".

Гибкость веба не означает отказ от контроля. Наоборот, как веб-дизайнеры мы ожидаем возможности делать осознанный выбор во всем, что составляет нашу работу и текст не исключение. Это и то, как располагается текст, его размер, шрифт и все, что позволяет донести основную идею сайта.

Главный инструмент для манипуляции видом текста в вебе это CSS.

Свойства CSS, рассматриваемые в этой статье, вы можете найти в [ модуле спецификации CSS текста](http://drafts.csswg.org/css-text-3/).

>Этот модуль описывает верстку CSS, то есть свойства CSS, управляющие переводом источника текста в форматированный и разделенный на строки текст.

Другими словами, модуль CSS текста это все, что касается вывода символов и слов в браузере, отступов, выравнивания, переносов и прочего.

Что считать базовой единицей текста или слова, где можно разбивать слова и прочие правила, зависит от языка сайта. Поэтому очень важно задавать данные об используемом языке в HTML-документе (обычно это атрибут `lang` в элементе `html`).

В этой статье я не буду обсуждать следующие вещи:

* шрифты, т.е. [визуальное представление символов](http://www.unicode.org/reports/tr17/#CharactersVsGlyphs) и их свойства;
* свойства CSS по декорированию текста, такие как подчеркивание, тени текста или акцентирование.


Если вы любопытны, вы найдете последнюю документацию о шрифтах и декорировании текста в [модуле CSS шрифты третьего уровня](http://drafts.csswg.org/css-fonts-3/) и в [модуле декорирования текста CSS третьего уровня](http://drafts.csswg.org/css-text-decor-3/).

## Управление регистром букв: `text-transform`

Иногда возникает необходимость вывести слова или первые символы слов с заглавной буквы. В CSS для управления регистром буквы есть свойство `text-transform`.

Дефолтное значение `text-transform` равно `none`,  то есть по умолчанию регистр букв не изменяется.

### Значение `capitalize`

Если вы хотите сделать заглавной первую букву каждого слова, оставив все остальные в первоначальном виде, то этого можно достичь задав значение `capitalize`.

Разметка:

```markup
<h2>alice's adventures in wonderland</h2>
```
Стили:

```css
h2 {
  text-transform: capitalize;
}
```

>![капитализация](/images/development/capitalize.png)


Отметьте, что `capitalize` не следует традиционным правилам --- оно делает заглавными первые буквы всех слов, включая предлоги. И если вы хотите следовать нормам английского языка, вам придется делать это вручную.

### Значение `uppercase`

Если ваша цель --- сделать все буквы заглавными, то подходящим значением будет `uppercase`:

Разметка:

```markup
<h2>alice's adventures in wonderland</h2>
```
Стили:

```css
h2 {
  text-transform: uppercase;
}
```

>![заглавный регистр текста](/images/development/uppercase.png)


### Значение `lowercase`

Это значение наоборот делает все символы строчными. Естественно, оно не оказывает никакого воздействия на уже имеющиеся строчные буквы.

Разметка:

```markup
<h2>alice's adventures in wonderland</h2>
```
Стили:

```css
h2 {
  text-transform: lowercase;
}
```

>![строчный регистр текста](/images/development/lowercase.png)

### Значение `full-width`

Это значение появилось в спецификации недавно. Это значение ограничивает символ внутри квадрата, аналогично иероглифам. И применение этого свойство облегчает выравнивание латинских символов с идеографическими.

Не у всех символов есть соответствующая форма, и, значит, не на все символы будет влиять это значение:

Разметка:

```markup
<h2>alice's adventures in wonderland</h2>
```
Стили:

```css
h2 {
  text-transform: full-width;
}
```
Это свойство на данный момент поддерживается только в Firefox.

>![полная ширина текста](/images/development/full-width.png)

### Дополнительная информация

Браузеры отлично поддерживают свойство `text-transform`, у всех основных браузеров с ним нет проблем.

Единственное исключение это значение `full-width`, которое работает пока только в Firefox. И такая непопулярность вполне может повлечь исключение этого значения из спецификаций.

Также есть небольшое отличие в обработке `capitalize` у Firefox и остальных браузеров.

Вот, например, Firefox:

![Капитализация текста в Firefox](/images/development/1440460727capitalize-hyphenated-firefox.jpg)

Заметьте, что первая буква после дефиса не капитализируется. А вот тот же самый пример в Chrome:

![Капитализация текста в Chrome](/images/development/1440460783capitalize-hyphenated-chrome.jpg)

В Chrome не делается исключений для первых букв после дефисов --- они переводятся в заглавный регистр также как остальные. И это является дефолтным поведением для всех браузеров, кроме упомянутого выше Firefox.

И, наконец, не забывайте о каскадировании. Задание свойства `text-transform` для элемента-контейнера будет унаследовано всеми его потомками. Чтобы избежать неожиданных результатов, задавайте дочерним элементам `text-transform` в значение `none`.

[Демонстрация значений свойства `text-transform`](http://codepen.io/SitePoint/pen/MwNvRO)

## Обработка пробелов: `white-space`

Когда вы нажимаете клавишу `Tab`, пробел или форсированно обрываете строку (с клавишей `ENTER` или тегом `<br>`), вы создаете пробелы в своем документе.

По умолчанию браузеры объединяют все последовательности пробелов в один, удаляют обрывы строки и заставляют строки занимать ширину контейнера. Это удобно  потому что позволяет делать отступы и разделять фрагменты текста, сохраняя исходник документа читаемым и поддерживаемым, не заботясь о его отображении в браузере.

Однако, что делать, если у нас другая цель? Предположим, вы хотите сохранить все пробелы, которые вы создали в HTML-документе. Или вы хотите, чтобы фрагмент текста выводился как сниппет кода, со всеми отступами. Или же вы хотите вывести текст в одну линию, без переносов.

В тех случаях, когда вам нужно изменить дефолтное поведение браузера, свойство `white-space` предлагает несколько интересных вариантов.

Ключевое слово `normal` идентично дефолтному поведению --- все лишние пробелы схлопываются в один, строка переводится после достижения края контейнера.

### Значение `pre`

Ключевое слово `pre` позволяет вам вывести текст с сохранением всех пробелов и всех форсированных переводов строки в исходнике. И при превышении пределов контейнера строка не будет обрываться.

```css
element {
  white-space: pre;  
}
```

![white-space-pre](/images/development/1440569470white-space-pre.jpg){: itemprop="image"}

![white-space-pre-code](/images/development/1440569514white-space-pre-code.jpg)


Если вы используете табы, то вы можете управлять их размером в пробелах с помощью свойства `tab-size`. Оно принимает значение в виде целого числа.

```css
element {
  white-space: pre;
  -moz-tab-size: 4;
  -o-tab-size: 4;
  tab-size: 4;
}
```

Свойство `tab-size` поддерживают [все современные браузеры, кроме браузеров от Microsoft (и даже Edge, увы)](http://caniuse.com/#search=tab-size), но если вы уверены, что вам это надо, используйте [полифилл](http://codepen.io/tjacobdesign/pen/Cjryo).

### Значение `pre-wrap`

Это значение позволяет сохранить все множественные пробелы на месте, но если строка не вмещается в контейнер, она автоматически переносится.

Ключевое слово `pre-wrap` позволяет вам достигнуть желаемого результата.

```css
element {
  white-space: pre-wrap;  
}
```

Отметьте, как каждая строка, выведенная в браузере, повторяет все переводы строки из исходника при наличии места в контейнере.

![white-space-pre-wrap](/images/development/1440460892white-space-pre-wrap.jpg)

![white-space-pre-wrap-code](/images/development/1440460922white-space-prewrap-source.jpg)

Однако, если вы уменьшите ширину браузера, вы заметите, что все строки ограничены шириной контейнера.

![white-space-pre-wrap-shrunk](/images/development/1440460949white-space-prewrap-shrunk.jpg)

### Значение `pre-line`

И, наконец, еще одно интересное значение свойства `white-space` --- `pre-line`. Оно действует как дефолтное в части схлопывания пробелов в один и ограничения строки размером контейнера. Однако оно отрабатывает все форсированные переводы строки.

```css
element {
  white-space: pre-line;
}
```

![white-space-pre-line](/images/development/1440460980white-space-pre-line.jpg)

![white-space-pre-code](/images/development/1440569588white-space-pre-line-code.jpg)

[Демо на Codepen со значениями `pre`, `pre-wrap` и `pre-line`](http://codepen.io/SitePoint/pen/vOoMLz).

### Значение `nowrap`

`nowrap` это, возможно, самое известное значение для `white-space`. Сталкивались вы с необходимостью задать какому-либо элементу дизайна неразрывность вне зависимости от ширины контейнера? Это делается с помощью `white-space: nowrap;`.

[Луис Лазарис](http://www.impressivewebs.com/css-white-space/) указывает на следующий случай использования этого значения.

![readmore-nowrap](/images/development/1440461034readmore.jpg)

На примере выше ссылка обозначена символом `»` и переносить его на следующую линию не желательно.

![readmore-dropped](/images/development/1440461060readmore-dropped.jpg)

В этом и подобных случаях поможет значение `nowrap`.

Другой интересный случай использования `nowrap` описан Сарой Свайдан в [справочнике по CSS от Codrops](http://tympanus.net/codrops/css_reference/white-space/). Сара указывает, что это значение можно применять к *любому строчному контенту*, включая изображения.

>Значение `nowrap` можно использовать для создания горизонтального списка изображений в скроллящемся элементе (карусели), обеспечивая их совместный вывод внутри контейнера.

Я проиллюстрирую это предложение, создав [базовую карусель на jQuery ](http://codepen.io/SitePoint/embed/NqQvQd?user=SitePoint&default-tab=result&slug-hash=NqQvQd&theme-id=6441&height=738#result-box) с использованием `white-space: nowrap`. Вот демо:


## Управляем переносом строки с разбитием слов

Иногда дизайн портиться из-за отдельных очень длинных слов, не переносящихся на следующую строку и переполняющих контейнер. Это может быть длинный URL или [комментарий с зажатой клавишей](http://www.impressivewebs.com/word-wrap-css3/).

Для таких случаев у нас есть специальные свойства CSS.

### Свойство `word-wrap/overflow-wrap`

Свойство `overflow-wrap` (раннее известное как `word-wrap` и до сих пор [поддерживаемое во всех основных браузерах](http://caniuse.com/#search=word-wrap)) работает, если свойство `white-space` допускает перенос в соответствии с размером строки. Возможные значения --- `normal` и `break-word`.

Со значением `normal` слова разбиваются на всех традиционных маркерах --- пробелы, дефисы и т.д.

Значение `break-word` позволяет разбить длинные слова, если иначе строка будет превышать доступный размер.

На картинке ниже изображен пример длинного слова, выходящего за пределы контейнера:

![Слово, выходящее за пределы контейнера](/images/development/1440461096no-wordwrap.jpg)

Теперь зададим этому элементу свойство `overflow-wrap` (и свойство `word-wrap` для совместимости) в значение `break-word`:

```markup
element {
  word-wrap: break-word;
  overflow-wrap: break-word;
}
```

Теперь сверхдлинное слово разбито на несколько строк, заполняющих всю ширину контейнера.

![Разбитие слова с word-wrap](/images/development/1440461127wordwrap.jpg)

### Свойство `hyphens`

Разбитие длинных слов это, конечно, хорошо. Однако, полученный текст может смутить читателей. Лучше будет, если разбитие слова будет сопровождаться установкой дефиса. Таким образом, читателям сразу становится ясно, что это одно слово, разделенное между строками. Этого можно достичь используя свойство `hyphens`, его можно сочетать с `word-wrap: break-word`.

Конкретно это значит, что значение `auto` свойства `hyphens` позволяет вывести дефис на месте разбития слова, если язык документа позволяет это делать в имеющемся источнике HTML. Чтобы это сработало, не забудьте задать правильный атрибут `lang` своему документу:

```css
.break-word.hyphens-auto {
  -moz-hyphens: auto;
  -webkit-hyphens: auto;
  -ms-hyphens: auto;
  hyphens: auto;
}
```

![Авто переносы слов с hyphens](/images/development/1440461161hyphens-auto.jpg)

Вы также можете отключить вывод дефисов, задав `hyphens` значение `none`:

```css
.break-word.hyphens-none {
  -moz-hyphens: none;
  -webkit-hyphens: none;
  -ms-hyphens: none;
  hyphens: none;
}
```

![Отключение дефисов](/images/development/1440461192hyphens-none.jpg)

Также у вас есть возможность вывести дефисы на разрывах строки там, где вы поставили их в разметке. Это делается с помощью значения `manual`:

```css
.break-word.hyphens-manual {
  -moz-hyphens: manual;
  -webkit-hyphens: manual;
  -ms-hyphens: manual;
  hyphens: manual;
}
```

![Переносы слов вручную](/images/development/1440461233hyphens-manual.jpg)

![Переносы слов вручную - исходник](/images/development/1440461261hyphens-manual-source.jpg)

Основные браузеры [поддерживают свойство `hyphens` с помощью вендорных префиксов](http://caniuse.com/#search=hyphens), но в реализации есть некоторые различия. Последние на момент написания статьи версии Chrome (44) и Opera (30) не поддерживали значение `auto`.

[Примеры с разбитием слов и переносами на Codepen](http://caniuse.com/#search=hyphens)

## Управляем пространством между словами и буквами

Читаемость фрагмент текста зачастую зависит от нескольких факторов. В некоторых случаях, уменьшение или увеличение пространства между словами или буквами, то есть трекинг существенно улучшает читаемость.

В CSS есть свойства `word-spacing` и `letter-spacing` для управления расстоянием между словами и буквами соответственно.

### Свойство `word-spacing`

Это свойство может принимать следующие значения:

* `normal`
* `<length>` (задание непосредственно числового значения в абсолютных единицах)
* `percentage` (задание значения в процентах)

`normal` выводит заданное по умолчанию расстояние между буквами. Это расстояние зависит от используемого шрифта и браузера.

```css
.normal {
  word-spacing: normal;
}
```

Числовое значение *добавляет* указанный промежуток к дефолтному ( *вычитает*, если задано отрицательное значение):

```css
.length {
  word-spacing: 0.5em;
}
```

Значение в процентах работает также как и числовое. На данный момент оно не поддерживается браузерами и, скорее всего, будет удалено из будущих черновиков спецификации.

```css
.percentage {
  word-spacing: 1%;
}
```

![задание расстояния между словами с word-spacing](/images/development/1440461290word-spacing.jpg)

### Свойство `letter-spacing`

Свойство `letter-spacing` принимает два вида значений: `normal` или числовое значение с единицами измерения.

Свойство `normal` сбрасывает любое раннее установленное значение `letter-spacing` на дефолтное. Например, если вы задали родительскому элементу `letter-spacing` в `1em`, вы можете отменить это для дочерних с помощью `normal`.

```css
element {
  letter-spacing: normal;
}
```

![letter-spacing в значении normal](/images/development/1440461323letter-spacing-normal.jpg)

Числовое значение задается в единицах исчисления, например в `em` или в пикселях, вы можете увеличить расстояние дефолтное расстояние или уменьшить задав отрицательное значение.

```css
element {
  letter-spacing: 1em;
}
```

![числовое значение letter-spacing](/images/development/1440461352letter-spacing-length.jpg)

### Дополнение

`word-spacing` применимо не только к словам --- его можно использовать с любым строчным или строчно-блочным содержимым.

Также вы можете анимировать `word-spacing` и `letter-spacing`. Однако в CSS-переходах значение `normal` в `letter-spacing` не работает в Firefox (39), просто замените значение на `0em`.

Вот [небольшое демо с анимацией текста](http://codepen.io/SitePoint/embed/RPXLrP?user=SitePoint&default-tab=result&slug-hash=RPXLrP&theme-id=6441&height=592#result-box), использующей `word-spacing` и `letter-spacing`:

## Опции CSS для выравнивания текста: `text-align`

Свойство `text-align` используется в вебе уже давно. Оно контролирует выравнивание строчного контента (текста или изображений) внутри блочного контейнера. Ключевые слова `left` и `right` выравнивают содержимое по соответствующим краям контейнера. `center` --- выравнивает по центру, а `justify` делает все строки одинаковой длины (кроме последней в абзаце).

В спецификации появилась пара новых значений, полезных для сайтов,использующих написание справа налево (RTL): `start` и `end`.

Для обычных языков  (LTR) они соответствуют  `left` и `right` соответственно. А для языков (RTL) `start` соответствует `right`, а   `end`  --- `left`.

```css
element {
  text-align: start;
}
```
![выравнивание текста start](/images/development/1440461375alignment-start.jpg)

```css
element {
  text-align: end;
}
```

![выравнивание текста end](/images/development/1440461400alignment-end.jpg)

Применение `text-align: match-parent` к дочернему элементу вынудит его унаследовать тоже выравнивание, что и у родительского элемента. И значения `start` и `end` в таком случае будут расчитаны исходя из направления языка родительского элемента.

## Свойство `text-align-last`

Это свойство отвечает за выравнивание последней строки абзаца текста. Оно принимает те же ключевые значения, что и `text-align`, за исключением того, что дефолтным является значение `auto`. `auto` выравнивает последнюю строку в соответствии со значением `text-align`, если `text-align` не задано используется значение `start`.

На момент написания, [это свойство плохо поддерживается браузерами](http://caniuse.com/#search=text-align-last). Поэтому пока стоит избегать его использования или делать это с осторожностью.

[Демо с современными свойствами для выравнивания текста на Codepen](http://codepen.io/SitePoint/pen/bdXoRr)

## Отступы в тексте: `text-indent`

Отступы в тексте обычно делаются в первой строке параграфа, хотя и не являются распространенной практикой на веб-сайтах. Вместо этого обычно помещается пустая строка, разделяющая параграфы.

Тем не менее, иногда отступ в первой строке иногда используется, например, для имитации классических книжных дизайнов.

![Отступ в тексте](/images/development/1440461429text-indent.jpg)

Если вы хотите использовать эту технику в своем дизайне, в CSS есть свойство `text-indent`. Рассмотрим его возможные значения.

Числовое значение можно задать в пикселях, em'aх и других поддерживаемых единицах:

```css
element {
  text-indent: 2em;
}
```
В том числе и в процентах от ширины контейнера:

```css
element {
  text-indent: 6%;
}
```

Значение `each-line` добавляет отступ не только первой строке, но и любой строке после разрыва строки (`ENTER` или `<br>`). На строки, переносимые по причине заполнения контейнера эти отступы не распространяются.

Значение `hanging` добавляет отступ ко всем строкам, кроме первой.

Два последних значения: `each-line` и `hanging` являются экспериментальными и не реализованы на данный момент ни в одном из браузеров.

[Демонстрация отступов текста на Codepen](http://codepen.io/SitePoint/pen/OVKxjp)
