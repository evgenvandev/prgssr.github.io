---
layout: post
title: Оформление содержимого &lt;use&gt; в SVG с помощью CSS
categories: [development]
tags: [css, translation, svg]
date: 2016-06-18 23:13:06 +0300
description: "Прошлогодняя статья Сары Суайдан о способах оформления use в SVG"
original: "http://tympanus.net/codrops/2015/07/16/styling-svg-use-content-css/"
original_title: "Styling SVG &lt;use&gt; Content with CSS"
original_author: "Сара Суайдан"
prism: yes
scripts: codepen
thumbnail: "/images/development/svg/StylingSVGuse.jpg"
---

Подробная статья об оформлении содержимого в элементе SVG `<use>` и преодолении связанных с этим проблем.

![StylingSVGuse](/images/development/svg/StylingSVGuse.jpg){: itemprop="image"}

Графика в формате SVG особо часто применяется для создания иконок и одной из самых распространенных техник для этого являются SVG-спрайты с использованием [SVG use для инстанцирования иконок](https://css-tricks.com/svg-sprites-use-better-icon-fonts/) в нужном месте документа.

Инстанцирование иконок или любого другого содержимого SVG в элементе `<use>` вызывает сложности при оформлении отдельных экземпляров. Цель этой статьи — дать вам обзор некоторых возможных способов  обойти ограничения оформления, связанные с использованием `<use>`.

Но перед тем как начать, давайте быстро рассмотрим основную структуру и группирование элементов в SVG, постепенно перейдя к `<use>`, DOM, а затем вернемся обратно к CSS. Мы разберем, почему оформление `<use>` может вызвать сложности и как их преодолеть.

## Краткий обзор структуры SVG, группирования и ссылок на элементы в SVG

SVG включает в себя 4 основных элемента для определения, структурирования и создания ссылок на содержимое SVG в документе. Эти элементы дают возможность многократного использования изображений, оставляя код читаемым и поддерживаемым. Из-за природы SVG некоторые из этих элементов имеют функциональность, аналогичную соответствующим командам в графических редакторах.

4 основных группирующих и связывающих элемента SVG это  `<g>`, `<defs>`, `<use>` and `<symbol>`.

Элемент `<g>` (сокращение от `“group”`) используется для логической группировки наборов связанных графических элементов. В терминах графических редакторов ( типа Adobe Illustrator) элемент `<g>` по функционалу похож на функцию "Сгруппировать объекты". Вы также можете думать о группе как о слое в графическом редакторе.

Группирование элементов полезно в тех случаях, когда вы хотите применить стиль ко всем элементам группы, а также, когда вы хотите анимировать все элементы группы, сохранив соотношение между ними.

Элемент `<defs>` используется для задания многих вещей, в основном это задание паттернов типа градиентов, которые затем можно использовать для заливки других элементов SVG. Его можно использовать для задания любых элементов, которые вы собираетесь использовать где-либо на холсте.

Элемент `<symbol>` комбинирует возможности  `<defs>` и `<g>` в том, что используется для группирования элементов с заданием шаблона, на который можно ссылаться в других участках документа. В отличие от `<defs>`, `<symbol>` не используется для задания паттернов; как правило он используется для создания символов типа иконок, которые затем применяются во всем документе.

У элемента `<symbol>` есть еще одно важное преимущество: он принимает атрибут  `viewBox`, который позволяет масштабирование внутри любой области видимости.

Элемент `<use>` позволяет вам использовать в любом месте документа ранее определенный элемент. Он позволяет многократно использовать элементы, дает функциональность подобную копированию-вставке в графическом редакторе. С ним можно использоваться как отдельный элемент, так и группа, заданная в  `<g>`, `<defs>` или `<symbol>`.

Чтобы использовать элемент вам надо передать ссылку на этот элемент, идентификатор — это атрибут `xlink:href`  и спозиционировать его, задав атрибуты  `x` и `y`. Вы можете применить стили к элементу `<use>` и они будут каскадироваться на содержимое этого элемента.

Но что является содержимым `<use>`? Куда он клонируется? И как каскад CSS работает с ним?

Перед тем как ответить на эти вопросы и с учетом того, что мы только по-быстрому разобрали структуру и группирование SVG, стоит упомянуть пару статей,которые позволят вам узнать больше об этих элементах, а также об атрибуте `viewBox` в элементе `<symbol>`:

* [Структурирование, группировка и ссылки в SVG — Элементы g, use, defs и symbol](http://sarasoueidan.com/blog/structuring-grouping-referencing-in-svg/)
* [Разбираемся в системе координат SVG (Часть 1): Viewport, viewBox и PreserveAspectRatio](http://sarasoueidan.com/blog/svg-coordinate-systems)


## SVG`<use>`  и теневой DOM

Когда вы ссылаетесь на элемент с помощью `<use>`, ваш код выглядит примерно так:

```markup
<symbol id="my-icon" viewBox="0 0 30 30">
	<!-- icon content / shapes here -->
</symbol>

<use xlink:href="#my-icon" x="100" y="300" />
```

На экране отображается иконка, содержимое которой определено внутри `<symbol>`, но на самом деле это содержимое элемента `<use>`, которое является клоном `<symbol>`.

Но элемент `<use>` это всего лишь один самозакрывающийся элемент — в нем нет контента между открывающим и закрывающим тегами, так куда же клонируется содержимое `<symbol>`?

Ответ  — в **теневой DOM** (почему-то он всегда у меня ассоциируется  с Бэтменом, не знаю почему).

### Что такое теневой DOM?

Теневой DOM идентичен обычному DOM, за исключением того, что вместо того, чтобы быть частью дерева основного документа, узлы теневого DOM относятся к фрагменту документа,  который является параллельным основному, но недоступным для его скриптов и стилей. Это дает авторам возможность создавать модульные компоненты, инкапсулируя скрипты и стили. Если вы когда-либо использовали элемент `video` или диапазонный ввод в HTML5 и не поняли, откуда появлялись элементы управления видеоплеером или слайдер, то ответ тот же — теневой DOM.

В случае с элементом SVG `<use>`, содержимое, на которое он ссылается, клонируется в фрагмент документа, "хостящийся" в `<use>`. В данном случае `<use>` это теневой хост.

Итак, содержимое `<use>` (клон или копия элемента, на который он ссылается) присутствует внутри теневого фрагмента документа.

Другими словами, содержимое находится там, но оно невидимое. Такое же, как и содержимое обычного DOM, но не доступное высокоуровневым средствам, таким как селекторы CSS и JavaScript, скопированное в фрагмент документа, привязанный к `<use>`.

Теперь, если вы дизайнер, вы можете подумать: "ОК, я понял, но есть ли способ проверить этот субдокумент и увидеть его содержимое". Ответ —  да, вы можете просматривать содержимое теневого DOM, используя инструменты разработки в Chrome (в Firefox на данный момент эта функция не доступна). Но для начала вам надо активировать инспектора теневого DOM во вкладке General на панели настроек. Это подробно описано [здесь](http://oliversmith.io/technology/2012/05/19/inspecting-the-shadow-dom-in-google-chrome-inspector/).

После того, как вы активировали инспекцию теневого DOM  в инструментах разработчика, вы можете видеть клонированные элементы на панели элементов, также как и элементы обычного DOM. На следующем изображении показан пример элемента `<use>`, ссылающегося на содержимое элемента `<symbol>`. Обратите внимание, что “#shadow-root”  и его содержимое являются клоном содержимого `<symbol>`.

![shadow-dom-in-chrome-inspector](/images/development/svg/shadow-dom.jpg)

*Используя инструменты разработчика Chrome, вы можете инспектировать содержимое элемента use внутри теневого DOM (“#shadow-root”, строка выделена серым цветом). На этом скриншоте инспектируется логотип Codrops из примера, который мы будем рассматривать в следующем разделе.*


Глядя на инспектируемый код, вы можете увидеть, что теневой DOM очень похож на обычный, за исключением того, как он обрабатывается CSS и JavaScript основного документа. Существуют также иные различия между ними, которые мы не будем рассматривать в этой статье по причине их объема, поэтому если вы хотите узнать больше, я рекомендую вам следующие статьи:

* [Введение в теневой DOM](http://code.tutsplus.com/tutorials/intro-to-shadow-dom--net-34966)
* [Что такое теневой DOM?](http://glazkov.com/2011/01/14/what-the-heck-is-shadow-dom/)
* [Теневой DOM 101](http://www.html5rocks.com/en/tutorials/webcomponents/shadowdom/) ([перевод на Frontender.info](http://frontender.info/shadowdom/))
* [Введение в теневой DOM](http://webcomponents.org/articles/introduction-to-shadow-dom/) (Видео)

С учетом моего ограниченного опыта взаимодействия с теневым DOM, я рассматриваю его как обычный DOM, который нужно по другому обрабатывать в части доступа CSS и JavaScript к его элементам. Это то, что важно для нас при работе с SVG: как воздействовать на содержимое `<use>` внутри теневого DOM, ведь нам важно иметь возможность оформлять его. Весь смысл использования `<use>` это возможность создавать различные копии элемента и в большинстве случаев нам надо иметь возможность стилизовать каждую копию по-разному. Например, это может быть лого в двух цветовых темах или многоцветные иконки для разных цветовых тем. Так что для нас важно иметь возможность сделать это с помощью CSS.

Как было сказано, содержимое теневого DOM  недоступно для CSS в отличие от обычного DOM. Так как нам стилизовать его? Мы не можем использовать путь к потомкам типа такого:

```css
use path#line {
    stroke: #009966;
}

```

Потому как у нас нет доступа к теневому DOM с помощью обычных CSS селекторов.

Существует [пара специальных селекторов](http://www.html5rocks.com/en/tutorials/webcomponents/shadowdom-201/#toc-style-cat-hat), проникающих в теневой DOM и применяющих стили к узлам внутри него, но они не только [плохо поддерживаются](http://caniuse.com/#feat=shadowdom), но и их возможности ограничены в сравнении с длинным списком селекторов CSS для обычного DOM.

Кроме того, нам нужен простой способ оформить содержимое SVG `<use>` без погружения в специфику теневого DOM, используя простой CSS и простой SVG.

Для того, чтобы добиться этого и получить больше контроля при оформлении содержимого `<use>`, нам нужно взглянуть на это под другим углом, использовав возможности каскадирования и наследования в CSS.

## Каскадирование стилей

Итак, CSS к SVG подключается тремя различными способами — внешними CSS стилями, внутренними стилями (внутри элемента `<style>`) и строчными стилями  (в атрибуте `style`), вся разница в каскадировании.

В дополнение к свойствам CSS, элементы SVG можно оформлять используя презентационные атрибуты. Презентационные атрибуты это сокращения для задания CSS-свойств элементу. Думайте о них как о специальных стилевых свойствах. Их природа позволяет использовать их в стилевом каскаде, но в несколько непривычном виде.

В следующем фрагменте кода мы получаем простой розовый круг с желтой обводкой. `stroke`, `stroke-width` и `fill` это презентационные атрибуты.

```markup
<svg viewBox="0 0 100 100">
    <circle fill="deepPink" stroke="yellow" stroke-width="5" cx="50" cy="50" r="10"></circle>
</svg>

```
В SVG подмножество CSS-свойств может быть задано  SVG-атрибутами и наоборот. Это значит, что не все CSS свойства могут быть заданы элементу SVG как презентационные атрибуты и не все презентационные атрибуты, доступные в SVG, могут быть определены в CSS.

Спецификация SVG перечисляет [атрибуты SVG, которые могут задаваться как свойства CSS](http://www.w3.org/TR/SVG/propidx.html). Некоторые из этих атрибутов есть среди обычных правил CSS, например, `opacity` и `transform`, а некоторые применяются только к SVG — `fill`, `stroke`  и `stroke-width`.

В SVG2 этот список также включает `x`, `y`, `width`, `height`, `cx`, `cy` и несколько иных презентационных атрибутов, которые нельзя задать по спецификации SVG 1.1. Новый список можно найти в [спецификации SVG2](http://www.w3.org/TR/SVG2/styling.html#SVGStylingProperties).

Возможно, вы, как и я ожидаете, что презентационные атрибуты имеют самую высокую специфичность среди всех стилевых правил. Ведь обычно внешние стили переписываются внутренними декларациями, а те в свою очередь переписываются строчными стилями атрибутов — они имеют максимальную специфичность, а, соответственно, и приоритет перед остальными стилями. И хотя это ожидание имеет смысл, действительный механизм работы отличен.

На самом деле, презентационные атрибуты рассматриваются как низкоуровневые "авторские таблицы стилей" и они переписываются остальными стилевыми декларациями: внешними, внутренними и инлайновыми стилями. Их единственная сила это приоритет перед унаследованными стилями. И все.

Теперь, когда мы выяснили это, вернемся к нашему элементу `<use>` и его содержимому.

Мы знаем, что мы не можем задать стили внутри  `<use>`, используя CSS селекторы.

Но мы также знаем, что как и в случае с элементом `<g>`, стили примененные к  `<use>` будут унаследованы всеми его потомками (которые находятся в теневом DOM).

Итак, сначала попытаемся изменить цвет заливки (`fill`) элемента внутри `<use>`, применив селектор к самому элементу `<use>` с расчетом, что каскад и наследование сделают свое дело.

Однако, это вызывает пару вопросов:

1. Цвет заливки будет унаследован *всеми потомками* элемента `<use>`, даже теми, к которым вы не хотите применять стили (но если внутри `<use>` у вас всего один элемент, то этой проблемы не будет).
2. Если вы экспортировали SVG из графического редактора или по каким-либо иным причинам не можете изменять код SVG, тогда вы в конечном итоге будете работать с SVG, к которому уже применены презентационные атрибуты (если вы явно не отмените это при экспорте в формат SVG) и значения этих атрибутов будут иметь приоритет над унаследованными от `<use>`.

И даже если вы можете редактировать код SVG и можете избавиться от них, я настоятельно рекомендую этого не делать по следующим причинам:

1. Удаление атрибутов ради последующей установки определенных свойств сбросит значения этих свойств на дефолтные, а это, как правило, черная заливка и обводка (применительно к цветам).
2. Сбрасывая значения, вы вынуждаете себя задавать стили для всего набора свойств.
3. Презентационные атрибуты, которые изначально заданы, являются отличным запасным вариантом на случай возникновения проблем с внешними стилями. Если CSS не загрузится, у ваших иконок будет по-прежнему привлекательный вид.

Итак, у нас есть эти атрибуты, но при этом мы хотим оформить различные экземпляры иконок по разному.

Это делается за счет вынуждения презентационных атрибутов к унаследованию стилей, заданных `<use>` или нахождения способа обойти переопределения этих значений. Чтобы сделать это, нам придется использовать всю мощь каскадирования CSS.

Давайте начнем с простых примеров и постепенно перейдем к сложным.

## Переписывание значений презентационных атрибутов с помощью CSS

Презентационные атрибуты переписываются любой декларацией стилей. Мы можем это использовать, для того, чтобы презентационный атрибут получил значение, унаследованное от стилей `<use>`.

Это просто благодаря ключевому слову CSS [inherits](http://tympanus.net/codrops/css_reference/inherit). Взгляните на следующий пример — иконка мороженого, нарисованная одним контуром, цвет которого мы хотим изменять в разных экземплярах. Иконка создана Эрин Агноли из [ Noun Project](https://thenounproject.com/).

```markup
<svg>
  <symbol id="ic">
    <path fill="#000" d="M81,40.933c0-4.25-3-7.811-6.996-8.673c-0.922-5.312-3.588-10.178-7.623-13.844  c-2.459-2.239-5.326-3.913-8.408-4.981c-0.797-3.676-4.066-6.437-7.979-6.437c-3.908,0-7.184,2.764-7.979,6.442  c-3.078,1.065-5.939,2.741-8.396,4.977c-4.035,3.666-6.701,8.531-7.623,13.844C22.002,33.123,19,36.682,19,40.933  c0,2.617,1.145,4.965,2.957,6.589c0.047,0.195,0.119,0.389,0.225,0.568l26.004,43.873c0.383,0.646,1.072,1.04,1.824,1.04  c0.748,0,1.439-0.395,1.824-1.04L77.82,48.089c0.105-0.179,0.178-0.373,0.225-0.568C79.855,45.897,81,43.549,81,40.933z   M49.994,11.235c2.164,0,3.928,1.762,3.928,3.93c0,2.165-1.764,3.929-3.928,3.929s-3.928-1.764-3.928-3.929  C46.066,12.997,47.83,11.235,49.994,11.235z M27.842,36.301c0.014,0,0.027,0,0.031,0c1.086,0,1.998-0.817,2.115-1.907  c0.762-7.592,5.641-13.791,12.303-16.535c1.119,3.184,4.146,5.475,7.703,5.475c3.561,0,6.588-2.293,7.707-5.48  c6.664,2.742,11.547,8.944,12.312,16.54c0.115,1.092,1.037,1.929,2.143,1.907c2.541,0.013,4.604,2.087,4.604,4.631  c0,1.684-0.914,3.148-2.266,3.958H25.508c-1.354-0.809-2.268-2.273-2.268-3.958C23.24,38.389,25.303,36.316,27.842,36.301z   M50.01,86.723L27.73,49.13h44.541L50.01,86.723z"/>
  </symbol>
</svg>

```

Содержимое нашей иконки с мороженым (`path`) определено внутри элемента `<symbol>` , а, значит, оно по умолчанию не будет выводится на холст.

Мы выводим множественные экземпляры иконки с помощью `<use>`.

```markup
<svg class="icon" viewBox="0 0 100 125"> 
    <use class="ic-1" xlink:href="#ic" x="0" y="0" />
</svg>
<svg class="icon" viewBox="0 0 100 125"> 
    <use class="ic-2" xlink:href="#ic" x="0" y="0" />
</svg>

```
Ширину и высоту иконок мы задаем с помощью CSS. Я использую те же размеры, что и у `viewBox`, но они не должны быть идентичными. Однако, чтобы избежать избытка пустого пространства внутри SVG, убедитесь, что вы сохраняете соотношение между сторонами.

```css
.icon {
    width: 100px;
    height: 125px;
}
```
С этим кодом мы получили следующий результат:

![use-svg-icons](/images/development/svg/Screen-Shot-2015-07-15-at-13.21.02.png)

Заметьте, что благодаря добавленным черным рамкам вокруг наших SVG вы видите границы каждого из них, в том числе и первого, в котором содержимое не рендерится. **Запомните: SVG-документ, в котором вы определили `symbol` будет выводится на страницу, но без содержимого**. Чтобы предотвратить это, используйте свойство `display: none` на первом SVG. Если вы не спрячете SVG с определениями иконок, он будет выводится на экран даже если вы не зададите для него размеры — он займет дефолтные 300 на 150 пикселей (это значение по умолчанию для незамещаемых элементов в CSS) и вы получите ненужный вам пустой блок на экране.

Теперь попробуем изменить цвет заливки для каждого экземпляра иконки:

```css
use.ic-1 {
    fill: skyblue;
}
use.ic-2 {
    fill: #FDC646;
}

```

Цвет заливки иконок по-прежнему не меняется, так как унаследованный цвет переписывается атрибутом `fill="#000"` в элементе `path`. Чтобы это не произошло, нам надо вынудить `path` унаследовать цвет:

```css
svg path {
    fill: inherit;
}
```

Вуаля! Цвета, заданные элементам `<use>` теперь применяются к `path` каждого из них. Проверьте демо и поэкспериментируйте со значениями, создавая экземпляры и задавая им разные цвета:

<p data-height="265" data-theme-id="0" data-slug-hash="mErELQ" data-default-tab="result" data-user="prgssr" data-embed-version="2" class="codepen">See the Pen <a href="http://codepen.io/prgssr/pen/mErELQ/">mErELQ</a> by prgssr (<a href="http://codepen.io/prgssr">@prgssr</a>) on <a href="http://codepen.io">CodePen</a>.</p>


Теперь эта техника работает, после того как мы вынудили содержимое `<use>` унаследовать стили. Но во многих случаях это не совсем то, что вам нужно. Есть и другие способы оформления, к некоторым из них мы сейчас перейдем.

### Оформление содержимого `<use>` с помощью свойства CSS `all`

Некоторое время назад, при работе над иконкой, активируемой с помощью  `<use>`, мне надо было, чтобы один из элементов внутри него унаследовал все стили `<use>`, такие как `fill`, `stroke`, `stroke-width`, `opacity` и даже `transform`. Таким образом, мне надо было контролировать все эти атрибуты через CSS, сохраняя при этом в разметке все презентационные атрибуты в качестве запасного варианта.

Если вы столкнетесь с похожей задачей, вы, вероятно, решите, что она займет слишком много времени, если все делать в CSS:

```css
path#myPath {
    fill: inherit;
    stroke: inherit;
    stroke-width: inherit;
    transform: inherit;
    /* ... */
}
```

Рассмотрев этот сниппет, вы заметите паттерн, а, значит, имело бы смысл  объединить все указанные свойства в одно и задать ему значение `inherit`.

К счастью, нам поможет свойство CSS `all`. В моем [справочнике по CSS ](http://tympanus.net/codrops/css_reference/all/) упоминается использование свойства `all` для оформления SVG, но стоит освежить наши знания.

Используя свойство `all` мы можем сделать так:

```css
path#myPath {
    all: inherit;
}
```

Это прекрасно работает во всех браузерах, поддерживающих `all`, однако надо учитывать следующий важный момент: эта декларация задает элементу наследование буквально всех свойств его родителя, в том числе и тех, которые вы не хотите задавать элементу. Поэтому, если вы не хотите, чтобы стилизовались все свойства CSS, вам это не подойдет — это крайняя мера и она частично подходит только тогда, когда у вас есть нестилизованный элемент и полный контроль над его свойствами в CSS. Если вы используете эту декларацию и не определяете значения для всех свойств CSS, они будут каскадироваться пока не найдут значение для наследования, в большинстве случаев это дефолтные стили браузера.

Заметьте, что это относится только к атрибутам, которые можно устанавливать с помощью CSS, а не к атрибутам, задаваемым только в SVG. Если атрибут может быть задан с помощью CSS — он унаследует стили, иначе нет.

Возможность активировать наследование презентационными атрибутами всех стилей `<use>`, но что если у вас иконка, состоящая из нескольких элементов и вы не хотите, чтобы все они унаследовали один и тот же цвет заливки? Что если вы хотите применять множество различных цветов заливки для разных потомков? Задание одного стиля в `<use>` уже не подходит. Нам нужно что-то другое, чтобы каскадировать нужные цвета к нужным элементам.

## Использование переменной CSS `currentColor` для оформления содержимого `<use>`

Использование переменной CSS [currentColor](http://tympanus.net/codrops/css_reference/color_value/#section_currentColor) в сочетании с техникой, описанной выше, позволяет определить два цвета для элемента, а не один. Год назад Фабрис Вайнберг написал об этом [статью в своем блоге на Codepen](http://codepen.io/FWeinb/blog/quick-tip-svg-use-style-two-colors).

Идея состоит в том, чтобы  одновременно применять к `<use>` свойства `fill` и `color`, а затем каскадировать эти свойства к содержимому `<use>`, используя возможности переменной `currentColor`. Посмотрим на пример кода, чтобы понять, как это работает.

Предположим, мы хотим оформить это минималистичное лого Codrops, используя 2 цвета — один для передней капли, а второй для задней.

![StylingSVGuse](/images/development/svg/StylingSVGuse_codropsdrops.png)

Во-первых, начнем с кода для этого изображения: у нас есть `symbol`, содержащий описание иконки и три экземпляра `<use>`, создающие три экземпляра лого.

```markup
<svg style="display: none;">
<symbol id="codrops" viewBox="0 0 23 30">
    <path class="back" fill="#aaa" d="M22.63,18.261c-0.398-3.044-2.608-6.61-4.072-9.359c-1.74-3.271-3.492-5.994-5.089-8.62l0,0   c-1.599,2.623-3.75,6.117-5.487,9.385c0.391,0.718,0.495,1.011,0.889,1.816c0.143,0.294,0.535,1.111,0.696,1.43   c0.062-0.114,0.582-1.052,0.643-1.162c0.278-0.506,0.54-0.981,0.791-1.451c0.823-1.547,1.649-2.971,2.469-4.33   c0.817,1.359,1.646,2.783,2.468,4.33c0.249,0.47,0.513,0.946,0.791,1.453c1.203,2.187,2.698,4.906,2.96,6.895   c0.292,2.237-0.259,4.312-1.556,5.839c-1.171,1.376-2.824,2.179-4.663,2.263c-1.841-0.084-3.493-0.887-4.665-2.263   c-0.16-0.192-0.311-0.391-0.448-0.599c-0.543,0.221-1.127,0.346-1.735,0.365c-0.56-0.019-1.095-0.127-1.599-0.313   c1.448,3.406,4.667,5.66,8.447,5.78C19.086,29.537,23.469,24.645,22.63,18.261z"/>
    <path class="front" fill="#ddd" d="M6.177,11.659c0.212,0.367,0.424,0.747,0.635,1.136c0.164,0.303,0.333,0.606,0.512,0.927   c0.683,1.225,1.618,2.898,1.755,3.937c0.144,1.073-0.111,2.056-0.716,2.769c-0.543,0.641-1.315,1.014-2.186,1.067   c-0.87-0.054-1.643-0.43-2.186-1.067c-0.604-0.713-0.858-1.695-0.715-2.771c0.137-1.036,1.072-2.712,1.755-3.936   c0.18-0.32,0.349-0.623,0.513-0.927C5.752,12.404,5.964,12.026,6.177,11.659 M6.177,5.966L6.177,5.966   c-1.02,1.649-2.138,3.363-3.247,5.419c-0.932,1.728-2.344,3.967-2.598,5.88c-0.535,4.014,2.261,7.09,5.846,7.203   c3.583-0.113,6.379-3.189,5.845-7.203c-0.255-1.912-1.666-4.152-2.598-5.88C8.314,9.329,7.196,7.617,6.177,5.966L6.177,5.966z"/>
</symbol>
</svg>
<svg height="90px" width="69px">
  <use xlink:href="#codrops" class="codrops-1"/>
</svg>
<svg height="90px" width="69px">
  <use xlink:href="#codrops" class="codrops-2"/>
</svg>
<svg height="90px" width="69px">
  <use xlink:href="#codrops" class="codrops-3"/>
</svg>
```

Если мы зададим цвет заливки (`fill`) в элементе `<use>` для каждого экземпляра, этот цвет будет унаследован обоими каплями, что не является нашей целью.

Поэтому вместо определения цвета заливки и каскадирования его обычным способом, мы будем использовать переменную `currentColor` , чтобы меньшая капля на переднем плане была другого цвета и это значение мы зададим с помощью свойства `color`.

Для начала нам надо вставить `currentColor` туда, где мы хотим применить этот цвет — это будет место в разметке, где определяется иконка, то есть внутри `<symbol>`. Теперь этот фрагмент выглядит так:

```markup
<svg style="display: none;">
	<symbol id="codrops" viewBox="0 0 23 30">
		<path class="back" fill="#aaa" d="..."/>
		<path class="front" fill="currentColor" d="..."/>
	</symbol>
</svg>
```

Затем нам надо удалить презентационный атрибут `fill` из второй капли и позволить ей унаследовать цвет заливки (`fill`) от элемента `<use>` с помощью `inherit`.

Если бы мы использовали ключевое слово `inherit`, чтобы вынудить презентационные атрибуты унаследовать значения от `<use>`, обе части унаследовали бы одинаковое значение, а `currentColor` не имела бы никакого эффекта. Поэтому в этой технике нам надо удалить тот атрибут, который мы хотим задать через CSS, а оставить только тот, в котором мы будем использовать `currentColor`.

```markup
<svg style="display: none;">
	<symbol id="codrops" viewBox="0 0 23 30">
		<path class="back" d="..."/>
		<path class="front" fill="currentColor" d="..."/>
	</symbol>
</svg>
```

Теперь, используя свойства  `fill` и `color` в `<use>` мы добавим стили к  капле из логотипа:

```css
.codrops-1 {
  fill: #4BC0A5;
  color: #A4DFD1;
}
.codrops-2 {
  fill: #0099CC;
  color: #7FCBE5;
}
.codrops-3 {
  fill: #5F5EC0;
  color: #AEAFDD;
}
```

Каждый элемент `<use>` получает собственное значение `fill` и `color`. В каждом из них цвет `fill` каскадируется и заполняет первый контур, не имеющий атрибута `fill`, а цвет свойства `color` используется для задания атрибута `fill` во втором контуре.

Так что произошло следующее: значение текущего цвета просочилось в стили содержимого элемента `<use>` за счет использования переменной `currentColor`. Изящно, не правда, ли?

Вот демо с использованным кодом:

<p data-height="265" data-theme-id="0" data-slug-hash="aZmZXV" data-default-tab="result" data-user="prgssr" data-embed-version="2" class="codepen">See the Pen <a href="http://codepen.io/prgssr/pen/aZmZXV/">aZmZXV</a> by prgssr (<a href="http://codepen.io/prgssr">@prgssr</a>) on <a href="http://codepen.io">CodePen</a>.</p>


Этот двухцветная техника отлично подходит для двухцветных лого.  В своей статье Фабрис создал три различных версии лого Sass, изменяя цвет текста относительно фона.

Ключевое слово `currentColor` это единственная доступная переменная CSS на данный момент. Однако, если бы у нас было бы больше переменных, могли бы мы их использовать для заполнения еще большего количества значений в содержимом `<use>`? Да, могли бы. Амелия Беллами-Ройдс год назад представила концепцию этого в своем [блоге на Codepen](https://codepen.io/AmeliaBR/post/customizable-svg-icons-css-variables). Посмотрим, как это работает.

## Будущее: оформление содержимого `<use>`  c помощью переменных CSS

Используя [кастомные свойства CSS (переменные CSS)](http://www.w3.org/TR/css-variables/) вы можете оформить содержимое `<use>`, не вынуждая браузер переписывать значения презентационных атрибутов.

Как [сказано на MDN](https://developer.mozilla.org/en-US/docs/Web/CSS/Using_CSS_variables), CSS переменные это сущности, заданные авторами или пользователями веб-страниц для хранения и использования определенных значений по всему документу.  Они задаются с использованием кастомных свойств и доступны с использованием специфичной нотации `var()`. Они очень похожи на переменные из CSS-препроцессоров, но более гибкие и могут [делать то, на что неспособны переменные препроцессоров](http://www.sitepoint.com/css-variables-can-preprocessors-cant/). (Скоро в [справочнике CSS](http://tympanus.net/codrops/css_reference/) появится статья о них).

Переменные CSS, как и переменные препроцессоров могут найти множество использований, но цветовая темизация это один из самых распространенных вариантов. И в этом разделе мы рассмотрим, как мы можем их применить при оформлении SVG.

Мы начнем с изображения, заданного в `symbol` и инстанцированного с помощью `<use>`, применив технику только к изображению; концепция примененная к стилю содержимого `<use>` может применяться к любому количеству элементов `<use>` на ваше усмотрение.

Мы будем использовать изображение этого прикольного робота-хипстера, созданного [Freepik](http://www.freepik.com/free-vector/cute-vector-hipster-robot-character_714905.htm).

![hipster-robot](/images/development/svg/Screen-Shot-2015-07-15-at-22.32.43.png)

Код робота содержит все составляющие его цвета:

```markup
<svg style="display: none">
    <symbol id="robot" viewBox="0 0 340 536">
        <path d="..." fill="#fff" />
        <path d="..." fill="#D1312C" />
        <path d="..." fill="#1E8F90" />
        <path d="..." fill="#1E8F90" />
        <path d="..." fill="#fff" />
        <path d="..." fill="#6A4933" />
        <path d="..." fill="#1E8F90"  />
        <path d="..." fill="#6A4933" />
        <path d="..." fill="#fff" />
        <path d="..." fill="#6A4933" />
        <path d="..." fill="#F2B42B" />
        <path d="..." fill="#fff" />
     
       <!-- rest of the shapes -->
    </symbol>
</svg>
```

Теперь, мы не будем использовать переменные CSS в качестве значений атрибута `fill` для каждого контура. Вместо этого мы будем их использовать в качестве цветов заливки используя свойство CSS `fill`, сохранив на месте все атрибуты `fill`. Эти атрибуты будут использоваться в качестве запасного варианта для браузеров, не поддерживающих переменные CSS — изображение будет выглядеть в своем изначальном виде, если переменные CSS не работают.

С добавленными переменными код будет следующим:

```markup
<svg style="display: none">
    <symbol id="robot" viewBox="0 0 340 536">
        <path d="..." fill="#fff" />
        <path d="..." fill="#D1312C" />
        <path d="..." fill="#1E8F90" style="fill: var(--primary-color)" />
        <path d="..." fill="#1E8F90" style="fill: var(--primary-color)" />
        <path d="..." fill="#fff" />
        <path d="..." fill="#6A4933" style="fill: var(--tertiary-color)" />
        <path d="..." fill="#1E8F90" style="fill: var(--primary-color)" />
        <path d="..." fill="#6A4933" style="fill: var(--tertiary-color)" />
        <path d="..." fill="#fff" />
        <path d="..." fill="#6A4933" style="fill: var(--tertiary-color)" />
        <path d="..." fill="#F2B42B" style="fill: var(--secondary-color)" />
        <path d="..." fill="#fff" />
       
        <!-- rest of the shapes -->
    </symbol>
</svg>
```

Так как инлайновые теги `style` переписывают презентационные атрибуты, браузеры с поддержкой CSS-переменных будут использовать эти переменные для задания цвета заливки (`fill`). А браузеры, не поддерживающие их, будут использовать атрибут `fill`.

Затем нам надо задать значения для переменных в CSS. Но сначала инстанцируем изображение с помощью `<use>`:

```markup
<svg width="340" height="536">
    <<use> xlink:href="#robot" id="robot-1" />
</svg>
```

После этого зададим значения переменных для `use`, чтобы они могли каскадироваться к его содержимому. Выбранные вами цвета создадут цветовую схему рисунка. Так как в нашем роботе используется три основных цвета, мы назовем их `primary`, `secondary` и `tertiary`. 

```css
#robot-1 {
  --primary-color: #0099CC;
  --secondary-color: #FFDF34;
  --tertiary-color: #333;
}
```

Вы по-прежнему можете использовать свойства  `fill` и `color` вместе с этими переменными, но вы можете вполне обойтись и без этого. Итак, с цветами заданными в наших переменных, робот выглядит так:

![hipster-robot-new-color](/images/development/svg/Screen-Shot-2015-07-15-at-22.54.53.png)

Вы можете использовать сколько угодно копий изображения и для каждой из них задать набор различных цветов, создав различные темы. Это частично полезно, когда вы хотите оформить лого различными способами в зависимости от контекста и в других подобных случаях.

Как было упомянуто, браузеры, не поддерживающие CSS-переменные используют заданные презентационные атрибуты в качестве запасного варианта, а браузеры с поддержкой переменных CSS используют их для заполнения свойства `fill` и переписывания атрибутов. Но что происходит, если браузер поддерживает переменные CSS, но вы забыли задать эти переменные в стилях или задали некорректное значение?

Для нашего робота-хипстера мы задали три переменных и только несколько его фрагментов не зависят от них — ведь он изначально разрабатывался для возможной темизации. Поэтому если вы запустите этот код в браузере с поддержкой переменных CSS  и удалите все декларации с объявлением этих переменных, вы получите следующий результат:

![black-hipster-robot](/images/development/svg/Screen-Shot-2015-07-15-at-22.59.37.png)

Если значения переменных не заданы или не корректны, браузер будет использовать свой цвет по умолчанию, а это обычно черный цвет для заливки и обводки в SVG.

Обойти это можно, задав другой цвет в качестве запасного варианта для поддерживающих браузеров. Синтаксис переменных CSS позволяет сделать так: вместо передачи функции `var()` имени переменной в качестве аргумента, вы передаете два аргумента, разделенных запятой — имя переменной и запасной вариант, в данном случае это будет значение для презентационного атрибута.

Итак, теперь код нашего робота выглядит так:

```markup
<svg style="display: none">
    <symbol id="robot" viewBox="0 0 340 536">
        <path d="..." fill="#fff" />
        <path d="..." fill="#D1312C" />
        <path d="..." fill="#1E8F90" style="fill: var(--primary-color, #1E8F90)" />
        <path d="..." fill="#1E8F90" style="fill: var(--primary-color, #1E8F90)" />
        <path d="..." fill="#fff" />
        <path d="..." fill="#6A4933" style="fill: var(--tertiary-color, #6A4933)" />
        <path d="..." fill="#1E8F90" style="fill: var(--primary-color, #1E8F90)" />
        <path d="..." fill="#6A4933" style="fill: var(--tertiary-color, #6A4933)" />
        <path d="..." fill="#fff" />
        <path d="..." fill="#6A4933" style="fill: var(--tertiary-color, #6A4933)" />
        <path d="..." fill="#F2B42B" style="fill: var(--secondary-color, #F2B42B)" />
        <path d="..." fill="#fff" />

         <!-- rest of the shapes -->
    </symbol>
</svg>
```
И это все. Если у какой-либо переменной не будет задано значение, у браузера всегда будет в запасе цвет, заданный в качестве запасного варианта. Замечательно.

Используя эту технику, вы можете выводить этого робота где угодно на странице с помощью `<use>`, задавая для каждого экземпляра разные цвета и получая различные цветовые темы в итоге.

Вы можете поэкспериментировать с демо, создать сколько угодно копий робота и раскрасить его любыми цветами — не забудьте только, что для этого обязательно надо использовать  браузер с [поддержкой переменных CSS](http://caniuse.com/#search=var):

<p data-height="465" data-theme-id="0" data-slug-hash="vKXXYP" data-default-tab="result" data-user="prgssr" data-embed-version="2" class="codepen">See the Pen <a href="http://codepen.io/prgssr/pen/vKXXYP/">vKXXYP</a> by prgssr (<a href="http://codepen.io/prgssr">@prgssr</a>) on <a href="http://codepen.io">CodePen</a>.</p>


Если вы просматриваете это демо в браузере с поддержкой переменных CSS, то среди прочих вы увидите голубую с желтым версию робота, как мы и задавали в CSS-переменных. Иначе вы увидите трех одинаковых роботов с  цветом запасного варианта.

## Подводя итоги

Это была большая статья.

Используя возможности каскада CSS, оформление содержимого `<use>`, хранимого в теневом DOM, становится менее сложным. А с переменными CSS (`currentColor` или с пользовательскими свойствами) мы можем проникнуть в теневой DOM и кастомизировать нашу графику, как хотим, создавая при этом запасной вариант на случай проблем.

Лично мне очень симпатично сочетание переменных CSS и SVG. Мне нравятся их совместный функционал, особенно в части создания механизма запасного варианта. 

Мы также можем получить другие способы оформления содержимого`<use>` в будущем, так как продолжаются [дискуссии](https://lists.w3.org/Archives/Public/www-svg/2014Nov/0000.html) об использовании переменных CSS в качестве параметров SVG — поэтому данная статья не покрывает все, что можно узнать по этой теме. 

Работа с многократно используемым содержимым SVG является одним из сложных вопросов SVG, это связано с  поведением и местом расположения клонируемого кода. Здесь возникает очень много смежных вопросов, которые могут стать темой отдельных статей.